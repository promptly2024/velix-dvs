generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AssessmentCategory {
  FINANCIAL_THREAT
  IDENTITY_THEFT_RISK
  PROFESSIONAL_EXPOSURE
  SOCIAL_MEDIA_VULNERABILITY
  HEALTHCARE_PRIVACY_RISK
  LOCATION_PRIVACY_THREAT
  COMMUNICATION_SECURITY
  DIGITAL_FOOTPRINT_RISK
  ACCOUNT_SECURITY_THREAT
  FAMILY_PERSONAL_SAFETY
  LEGAL_COMPLIANCE_RISK
  EDUCATIONAL_RECORDS_EXPOSURE
  DIGITAL_REPUTATION_THREAT
}

enum IncidentSeverity {
  HIGH
  MEDIUM
  LOW
}

enum GameStatus {
  IN_PROGRESS
  COMPLETED
}

enum UserRole {
  ADMIN
  USER
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  password     String
  username     String   @unique
  profileImage String?
  dvsScore     Decimal? @db.Decimal(10, 2)
  role                   UserRole                 @default(USER)
  otp                    String?
  otpExpiry              DateTime?
  emailVerified          Boolean                  @default(false)
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @default(now())
  documents              Document[]
  assessments            Assessment[]
  incidents              Incident[]
  gameProgress           GameProgress[]
  achievements           Achievement[]
  breachChecks           BreachCheck[]
  passwordChecks         PasswordCheck[]
  webPresences           WebPresence[]
  digitalFootprints      DigitalFootprint[]
  UserIngredientExposure UserIngredientExposure[]
  ThreatAssessment       ThreatAssessment[]
  levelAttempts          UserLevelAttempt[]
}

model Document {
  id           String   @id @default(uuid())
  userId       String
  fileUrl      String
  documentType String
  scanResults  Json?
  riskScore    Int?     @default(0)
  ocrText      String? // extracted text
  ocrStatus    String?  @default("pending") // 'pending' | 'success' | 'failed'
  uploadedAt   DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id])
}

model Assessment {
  id              String                    @id @default(uuid())
  userId          String
  startedAt       DateTime                  @default(now())
  finishedAt      DateTime?
  score           Int
  recommendations Json?
  categories      AssessmentCategoryScore[]
  createdAt       DateTime                  @default(now())
  user            User                      @relation(fields: [userId], references: [id])
}

model AssessmentCategoryScore {
  id           String             @id @default(uuid())
  assessmentId String
  category     AssessmentCategory
  score        Int
  assessment   Assessment         @relation(fields: [assessmentId], references: [id])
}

model Incident {
  id          String           @id @default(uuid())
  userId      String
  severity    IncidentSeverity
  description String
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User             @relation(fields: [userId], references: [id])
}

model GameProgress {
  id            String     @id @default(uuid())
  userId        String
  module        String
  level         Int
  xp            Int
  completedAt   DateTime?
  currentStatus GameStatus
  user          User       @relation(fields: [userId], references: [id])
}

model Achievement {
  id          String   @id @default(uuid())
  userId      String
  title       String
  description String?
  badgeImage  String?
  achievedAt  DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id])
}

model BreachCheck {
  id            String         @id @default(uuid())
  userId        String
  email         String
  checkType     CheckType
  breachesFound Int            @default(0)
  checkedAt     DateTime       @default(now())
  user          User           @relation(fields: [userId], references: [id])
  breachRecords BreachRecord[]
}

enum CheckType {
  EMAIL
  PASSWORD
  BATCH
}

model BreachRecord {
  id            String      @id @default(uuid())
  breachCheckId String
  breachName    String
  breachTitle   String
  domain        String?
  breachDate    DateTime
  addedDate     DateTime
  pwnCount      Int
  description   String      @db.Text
  dataClasses   String[]
  isVerified    Boolean
  isSensitive   Boolean
  isRetired     Boolean
  isFabricated  Boolean
  breachCheck   BreachCheck @relation(fields: [breachCheckId], references: [id])
  createdAt     DateTime    @default(now())

  @@index([breachCheckId])
  @@index([breachName])
}

model PasswordCheck {
  id           String   @id @default(uuid())
  userId       String
  passwordHash String
  isPwned      Boolean
  pwnCount     Int      @default(0)
  checkedAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id])
}

model WebPresence {
  id            String               @id @default(uuid())
  userId        String
  email         String
  scanDate      DateTime             @default(now())
  totalFindings Int                  @default(0)
  riskScore     Int                  @default(0)
  user          User                 @relation(fields: [userId], references: [id])
  findings      WebPresenceFinding[]

  @@index([userId])
  @@index([email])
}

model WebPresenceFinding {
  id            String        @id @default(uuid())
  webPresenceId String
  platform      String
  platformType  PlatformType
  url           String
  snippet       String?       @db.Text
  profileName   String?
  exposureLevel ExposureLevel
  detectedAt    DateTime      @default(now())
  webPresence   WebPresence   @relation(fields: [webPresenceId], references: [id])

  @@index([webPresenceId])
  @@index([platform])
}

model DigitalFootprint {
  id                String   @id @default(uuid())
  userId            String
  email             String
  totalExposure     Int      @default(0)
  socialMediaCount  Int      @default(0)
  professionalCount Int      @default(0)
  dataBreachCount   Int      @default(0)
  overallRiskScore  Int      @default(0)
  lastScanned       DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id])

  @@unique([userId, email])
  @@index([userId])
  @@index([email])
}

enum PlatformType {
  SOCIAL_MEDIA
  PROFESSIONAL
  FORUM
  BLOG
  NEWS
  MARKETPLACE
  DATING
  GAMING
  OTHER
}

enum ExposureLevel {
  HIGH
  MEDIUM
  LOW
}

// THREAT SYSTEM MODELS
// 13 Threats isme add honge
model ThreatCategory {
  id               String             @id @default(uuid())
  key              String             @unique
  name             String
  description      String?
  ingredients      ThreatIngredient[]
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  ThreatAssessment ThreatAssessment[]
}

// har threat ke ingredient like email_leaked
model ThreatIngredient {
  id               String            @id @default(uuid())
  threatCategoryId String
  key              String            @unique
  name             String
  detectionSources DetectionSource[]
  possibleScam     String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  threatCategory         ThreatCategory           @relation(fields: [threatCategoryId], references: [id])
  UserIngredientExposure UserIngredientExposure[]
}

// user ke liye kaun se ingredient mile
model UserIngredientExposure {
  id              String         @id @default(uuid())
  userId          String
  ingredientId    String
  valueMasked     String?
  source          ExposureSource
  confidence      Float          @default(0.0)
  evidenceUrl     String?
  evidenceSnippet String?        @db.Text
  detectedAt      DateTime       @default(now())

  user       User             @relation(fields: [userId], references: [id])
  ingredient ThreatIngredient @relation(fields: [ingredientId], references: [id])

  @@index([userId])
  @@index([ingredientId])
}

// har user ke liye har threat ke liye score
model ThreatAssessment {
  id                 String   @id @default(uuid())
  userId             String
  threatId           String
  score              Int
  matchedIngredients String[] // list of ingredient keys
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user   User           @relation(fields: [userId], references: [id])
  threat ThreatCategory @relation(fields: [threatId], references: [id])

  @@index([userId])
  @@index([threatId])
}

// ENUMS
enum DetectionSource {
  BREACH
  WEB_SEARCH
  SOCIAL_SEARCH
  AI_PROMPT
  DARK_WEB
}

enum ExposureSource {
  BREACH
  WEB
  SOCIAL
  AI
}

// GAMIFIED MODE
// ENUMS for the Gamified Mode
enum SceneMediaType {
  VIDEO
  IMAGES
  TEXT
}

enum LevelType {
  EASY
  MEDIUM
  HARD
}

// Level structure (Admin Uploaded)
model GameLevel {
  id               String             @id @default(uuid())
  levelNumber      Int                @unique // e.g., 1, 2, 3...
  title            String // e.g "OTP Theft"
  description      String?
  type             LevelType          @default(EASY)
  requiredScore    Int // Score needed to pass the level
  basePoints       Int // Base points awarded for passing
  scenes           LevelScene[] // Scenes within this level
  UserLevelAttempt UserLevelAttempt[]

  @@index([levelNumber])
}

// Scene/Step within a Level (Admin Uploaded)
// Represents the scenario (video/images) the user sees before questions
model LevelScene {
  id          String         @id @default(uuid())
  levelId     String
  sceneNumber Int // Sequence in which the scene appears
  sceneType   SceneMediaType @default(VIDEO) // VIDEO, IMAGES, TEXT
  mediaUrls   String[] // Array of media URLs (video or images)
  queries     SceneQuery[] // One or more questions/queries after the visual
  level       GameLevel      @relation(fields: [levelId], references: [id])

  @@unique([levelId, sceneNumber])
}

// Question asked after a scene's media is viewed
model SceneQuery {
  id              String        @id @default(uuid())
  sceneId         String
  queryNumber     Int // Sequence of the question within the scene
  questionText    String        @db.Text
  learningOutcome String?       @db.Text // Key takeaway (e.g., "OTP kisi ko nahi dena chahiye")
  hintText        String?       @db.Text // Hint available on request
  options         QueryOption[]

  scene        LevelScene     @relation(fields: [sceneId], references: [id])
  UserResponse UserResponse[] // Linking user response to the specific query

  @@unique([sceneId, queryNumber])
}

// Options for a specific SceneQuery (Admin Uploaded)
model QueryOption {
  id            String  @id @default(uuid())
  queryId       String
  optionText    String
  isCorrect     Boolean @default(false)
  pointsAwarded Int     @default(0) // Points for selecting this option

  query SceneQuery @relation(fields: [queryId], references: [id])

  @@index([queryId])
}

// User Progress/Attempts (User specific - Dynamic Data)
model UserLevelAttempt {
  id            String  @id @default(uuid())
  userId        String
  levelId       String
  attemptNumber Int     @default(1)
  isPassed      Boolean @default(false)
  scoreAchieved Int     @default(0)

  // Tracks current position for IN_PROGRESS status
  currentSceneNumber Int @default(1)
  currentQueryNumber Int @default(1)

  startedAt  DateTime  @default(now())
  finishedAt DateTime?

  user      User           @relation(fields: [userId], references: [id])
  level     GameLevel      @relation(fields: [levelId], references: [id])
  responses UserResponse[]

  @@unique([userId, levelId, attemptNumber])
  @@index([userId, levelId])
}

// Model to track the specific response given by a user in an attempt
model UserResponse {
  id               String  @id @default(uuid())
  attemptId        String
  queryId          String
  selectedOptionId String
  isCorrect        Boolean
  pointsEarned     Int

  isFirstTry Boolean @default(true)

  respondedAt DateTime @default(now())

  attempt UserLevelAttempt @relation(fields: [attemptId], references: [id])
  query   SceneQuery       @relation(fields: [queryId], references: [id])

  @@unique([attemptId, queryId])
}
